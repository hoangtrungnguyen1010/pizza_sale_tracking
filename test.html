<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto-Converting Video Player</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .video-container {
            position: relative;
            margin: 20px 0;
            border: 2px dashed #ddd;
            border-radius: 8px;
            overflow: hidden;
        }
        
        #video {
            width: 100%;
            height: auto;
            display: block;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            cursor: crosshair;
        }
        
        #canvas.drawing {
            pointer-events: auto;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }
        
        .file-input-label {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            display: inline-block;
            transition: background 0.3s;
        }
        
        .file-input-label:hover {
            background: #0056b3;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        #processBtn {
            background: #28a745;
            color: white;
        }
        
        #processBtn:hover:not(:disabled) {
            background: #218838;
        }
        
        .progress-container {
            margin: 20px 0;
            display: none;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #28a745);
            width: 0%;
            transition: width 0.3s;
        }
        
        .progress-text {
            text-align: center;
            margin-top: 10px;
            font-weight: bold;
        }
        
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .status.warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .codec-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Auto-Converting Video Player</h1>
        <p>Upload an MP4 file. If it's not browser-compatible, it will be automatically converted using FFmpeg.</p>
        
        <div class="controls">
            <div class="file-input-wrapper">
                <input type="file" id="uploadBtn" accept=".mp4,video/mp4">
                <label for="uploadBtn" class="file-input-label">Choose MP4 File</label>
            </div>
            <button id="processBtn" disabled title="Draw a rectangle and upload a video first">Process Video</button>
        </div>
        
        <div id="status" class="status"></div>
        
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">Converting video...</div>
        </div>
        
        <div class="video-container">
            <video id="video" controls preload="metadata"></video>
            <canvas id="canvas"></canvas>
        </div>
        
        <div id="codecInfo" class="codec-info" style="display: none;"></div>
    </div>

    <!-- FFmpeg WebAssembly -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ffmpeg/0.12.10/ffmpeg.min.js"></script>
    
    <script>
        // Enhanced video player with automatic FFmpeg conversion
        class VideoConverter {
            constructor() {
                this.ffmpeg = null;
                this.ffmpegLoaded = false;
                this.initElements();
                this.initEventListeners();
                this.loadFFmpeg();
            }

            initElements() {
                this.uploadBtn = document.getElementById('uploadBtn');
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.processBtn = document.getElementById('processBtn');
                this.status = document.getElementById('status');
                this.progressContainer = document.getElementById('progressContainer');
                this.progressFill = document.getElementById('progressFill');
                this.progressText = document.getElementById('progressText');
                this.codecInfo = document.getElementById('codecInfo');
                
                this.isDrawing = false;
                this.rect = {};
                this.hasRect = false;
                this.videoLoaded = false;
                this.currentFile = null;
            }

            async loadFFmpeg() {
                try {
                    this.showStatus('Loading FFmpeg... This may take a moment on first load.', 'info');
                    
                    const { FFmpeg } = FFmpegWASM;
                    this.ffmpeg = new FFmpeg();
                    
                    // Set up progress logging
                    this.ffmpeg.on('log', ({ message }) => {
                        console.log('FFmpeg:', message);
                        if (message.includes('time=')) {
                            this.updateConversionProgress(message);
                        }
                    });
                    
                    await this.ffmpeg.load();
                    this.ffmpegLoaded = true;
                    this.showStatus('FFmpeg loaded successfully! Ready to convert videos.', 'success');
                    setTimeout(() => this.hideStatus(), 3000);
                } catch (error) {
                    console.error('Failed to load FFmpeg:', error);
                    this.showStatus('Failed to load FFmpeg. Video conversion will not be available.', 'error');
                }
            }

            initEventListeners() {
                this.uploadBtn.addEventListener('change', this.handleFileUpload.bind(this));
                this.video.addEventListener('error', this.handleVideoError.bind(this));
                this.video.addEventListener('loadedmetadata', this.handleVideoLoaded.bind(this));
                this.video.addEventListener('play', this.startDrawingLoop.bind(this));
                this.video.addEventListener('pause', this.drawOverlay.bind(this));
                this.video.addEventListener('seeked', this.drawOverlay.bind(this));
                
                // Canvas drawing events
                this.canvas.addEventListener('mousedown', this.startDrawing.bind(this));
                this.canvas.addEventListener('mousemove', this.drawRectangle.bind(this));
                this.canvas.addEventListener('mouseup', this.finishDrawing.bind(this));
            }

            showStatus(message, type = 'info') {
                this.status.textContent = message;
                this.status.className = `status ${type}`;
                this.status.style.display = 'block';
            }

            hideStatus() {
                this.status.style.display = 'none';
            }

            showProgress(show = true) {
                this.progressContainer.style.display = show ? 'block' : 'none';
                if (!show) {
                    this.progressFill.style.width = '0%';
                }
            }

            updateProgress(percent, text = 'Converting video...') {
                this.progressFill.style.width = `${percent}%`;
                this.progressText.textContent = text;
            }

            updateConversionProgress(logMessage) {
                // Parse FFmpeg log for progress
                const timeMatch = logMessage.match(/time=(\d+):(\d+):(\d+\.\d+)/);
                if (timeMatch && this.video.duration) {
                    const hours = parseInt(timeMatch[1]);
                    const minutes = parseInt(timeMatch[2]);
                    const seconds = parseFloat(timeMatch[3]);
                    const currentTime = hours * 3600 + minutes * 60 + seconds;
                    const progress = Math.min((currentTime / this.video.duration) * 100, 100);
                    this.updateProgress(progress, `Converting... ${progress.toFixed(1)}%`);
                }
            }

            async handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                this.currentFile = file;
                this.showStatus('Checking video compatibility...', 'info');

                // Test if video can play directly
                const canPlay = await this.testVideoPlayback(file);
                
                if (canPlay) {
                    this.showStatus('Video is compatible! Loading...', 'success');
                    this.loadVideo(file);
                } else {
                    if (this.ffmpegLoaded) {
                        this.showStatus('Video needs conversion. Starting FFmpeg conversion...', 'warning');
                        await this.convertVideo(file);
                    } else {
                        this.showStatus('Video is not compatible and FFmpeg is not loaded. Please try a different file.', 'error');
                    }
                }
            }

            testVideoPlayback(file) {
                return new Promise((resolve) => {
                    const testVideo = document.createElement('video');
                    const url = URL.createObjectURL(file);
                    
                    const timeout = setTimeout(() => {
                        cleanup();
                        resolve(false);
                    }, 5000);

                    const cleanup = () => {
                        clearTimeout(timeout);
                        URL.revokeObjectURL(url);
                        testVideo.remove();
                    };

                    testVideo.onloadedmetadata = () => {
                        cleanup();
                        resolve(true);
                    };

                    testVideo.onerror = () => {
                        cleanup();
                        resolve(false);
                    };

                    testVideo.src = url;
                });
            }

            async convertVideo(file) {
                try {
                    this.showProgress(true);
                    this.updateProgress(0, 'Preparing conversion...');

                    // Write input file to FFmpeg file system
                    const inputName = 'input.mp4';
                    const outputName = 'output.mp4';
                    
                    this.updateProgress(10, 'Loading file into FFmpeg...');
                    await this.ffmpeg.writeFile(inputName, new Uint8Array(await file.arrayBuffer()));

                    this.updateProgress(20, 'Starting conversion...');
                    
                    // Run FFmpeg conversion
                    await this.ffmpeg.exec([
                        '-i', inputName,
                        '-c:v', 'libx264',
                        '-preset', 'fast',  // Faster conversion
                        '-crf', '23',       // Good quality/size balance
                        '-c:a', 'aac',
                        '-movflags', '+faststart',
                        '-y',               // Overwrite output
                        outputName
                    ]);

                    this.updateProgress(90, 'Finalizing conversion...');
                    
                    // Read the converted file
                    const data = await this.ffmpeg.readFile(outputName);
                    const convertedBlob = new Blob([data.buffer], { type: 'video/mp4' });
                    
                    // Clean up FFmpeg file system
                    await this.ffmpeg.deleteFile(inputName);
                    await this.ffmpeg.deleteFile(outputName);

                    this.updateProgress(100, 'Conversion complete!');
                    this.showStatus('Video converted successfully!', 'success');
                    
                    // Load the converted video
                    this.loadVideo(convertedBlob);
                    
                    setTimeout(() => {
                        this.showProgress(false);
                        this.hideStatus();
                    }, 2000);

                } catch (error) {
                    console.error('Conversion failed:', error);
                    this.showStatus(`Conversion failed: ${error.message}`, 'error');
                    this.showProgress(false);
                }
            }

            loadVideo(file) {
                const url = URL.createObjectURL(file);
                this.video.src = url;
                this.video.load();
                
                // Reset drawing state
                this.hasRect = false;
                this.rect = {};
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.updateButtonState();
            }

            handleVideoError(e) {
                const error = this.video.error;
                let message = 'Error loading video: ';
                
                if (error) {
                    switch (error.code) {
                        case error.MEDIA_ERR_DECODE:
                            message += 'Video codec not supported. Trying conversion...';
                            if (this.currentFile && this.ffmpegLoaded) {
                                this.convertVideo(this.currentFile);
                                return;
                            }
                            break;
                        case error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                            message += 'Video format not supported. Trying conversion...';
                            if (this.currentFile && this.ffmpegLoaded) {
                                this.convertVideo(this.currentFile);
                                return;
                            }
                            break;
                        default:
                            message += 'Unknown error occurred.';
                    }
                }
                
                this.showStatus(message, 'error');
                this.videoLoaded = false;
                this.updateButtonState();
            }

            handleVideoLoaded() {
                this.canvas.width = this.video.videoWidth;
                this.canvas.height = this.video.videoHeight;
                this.canvas.style.width = '100%';
                this.canvas.style.height = '100%';
                this.video.style.width = '100%';
                this.video.style.height = '100%';
                
                this.videoLoaded = true;
                this.updateButtonState();
                this.drawOverlay();
                
                this.showCodecInfo();
                console.log(`Video loaded: ${this.video.videoWidth}x${this.video.videoHeight}`);
            }

            showCodecInfo() {
                const info = `
Video Information:
- Dimensions: ${this.video.videoWidth}x${this.video.videoHeight}
- Duration: ${this.video.duration?.toFixed(2) || 'Unknown'} seconds
- Ready State: ${this.video.readyState}
- Network State: ${this.video.networkState}
                `.trim();
                
                this.codecInfo.textContent = info;
                this.codecInfo.style.display = 'block';
            }

            // Drawing methods
            drawOverlay() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                if (this.hasRect && this.rect.width && this.rect.height) {
                    this.ctx.strokeStyle = 'red';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(this.rect.startX, this.rect.startY, this.rect.width, this.rect.height);
                }
            }

            startDrawingLoop() {
                const drawFrame = () => {
                    if (!this.video.paused && !this.video.ended) {
                        this.drawOverlay();
                        requestAnimationFrame(drawFrame);
                    }
                };
                drawFrame();
            }

            startDrawing(e) {
                if (!this.videoLoaded) return;
                
                this.isDrawing = true;
                this.hasRect = false;
                
                const rect = this.canvas.getBoundingClientRect();
                this.rect.startX = (e.clientX - rect.left) * (this.canvas.width / this.canvas.offsetWidth);
                this.rect.startY = (e.clientY - rect.top) * (this.canvas.height / this.canvas.offsetHeight);
                this.rect.width = 0;
                this.rect.height = 0;
                
                this.canvas.classList.add('drawing');
                this.canvas.style.pointerEvents = 'auto';
            }

            drawRectangle(e) {
                if (!this.isDrawing) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const currX = (e.clientX - rect.left) * (this.canvas.width / this.canvas.offsetWidth);
                const currY = (e.clientY - rect.top) * (this.canvas.height / this.canvas.offsetHeight);
                
                this.rect.width = currX - this.rect.startX;
                this.rect.height = currY - this.rect.startY;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.strokeStyle = 'rgba(255,0,0,0.7)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([6]);
                this.ctx.strokeRect(this.rect.startX, this.rect.startY, this.rect.width, this.rect.height);
                this.ctx.setLineDash([]);
            }

            finishDrawing(e) {
                if (!this.isDrawing) return;
                
                this.isDrawing = false;
                this.hasRect = Math.abs(this.rect.width) > 10 && Math.abs(this.rect.height) > 10;
                
                this.canvas.classList.remove('drawing');
                this.canvas.style.pointerEvents = 'none';
                
                this.drawOverlay();
                this.updateButtonState();
            }

            updateButtonState() {
                if (this.videoLoaded && this.hasRect) {
                    this.processBtn.disabled = false;
                    this.processBtn.setAttribute('title', '');
                } else {
                    this.processBtn.disabled = true;
                    this.processBtn.setAttribute('title', 'Draw a rectangle and upload a video first');
                }
            }
        }

        // Initialize the video converter when page loads
        window.addEventListener('DOMContentLoaded', () => {
            new VideoConverter();
        });
    </script>
</body>
</html>